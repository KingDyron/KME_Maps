type 
	TKMMessage = record
		ID : Integer;
		Time : Cardinal;
		Loc : TKMPoint;
	end;
const
	WIN_AFTER_GETTING_ALL_WARES = true;
	WIN_MSG = 18;
	CHEAT_MSG = 22;
	BUILD_HOUSE_MSG = 24;
	GATHER_WARES = 23;
	EQUIP_UNITS = 25;
	MSG_DELAY = 150;
	
var Messages : array of TKMMessage;
	ResourcesToGather : array of record
		WT : TKMWareType;
		Count : Integer;
	end;
	UnitsToEquip : array of record
		UT : TKMUnitType;
		Count : Integer;
	end;
	HousesBuilt : array[0 .. 65] of Boolean;
	
	MessageAdded : array[0..64] of Boolean; 
	OverlayTopMessage : String;
	WinTime : Cardinal;
	BuildHouses :array of TKMHouseType;
	MustBuildShaft,
	UnlockDev: Boolean;
	
procedure AddWaresToGather(aWareType : TKMWareType; aCount : Integer);
begin
	SetLength(ResourcesToGather, length(ResourcesToGather) + 1);
	ResourcesToGather[high(ResourcesToGather)].WT := aWareType;
	ResourcesToGather[high(ResourcesToGather)].Count := aCount;
end;
procedure AddMultiWaresToGather(aWareTypes :array of TKMWareType; aCount : Integer);
var I : Integer;
begin
	for I := 0 to high(aWareTypes) do 
		AddWaresToGather(aWareTypes[I], aCount);
end;
procedure RemoveWaresToGather(aIndex : Integer);
var I: Integer;
begin
	for I := aIndex to high(ResourcesToGather) - 1 do
		ResourcesToGather[I] := ResourcesToGather[I + 1];
	SetLength(ResourcesToGather, high(ResourcesToGather));
end;

procedure AddUnitsToEquip(aUnitType : TKMUnitType; aCount : Integer);
begin
	SetLength(UnitsToEquip, length(UnitsToEquip) + 1);
	UnitsToEquip[high(UnitsToEquip)].UT := aUnitType;
	UnitsToEquip[high(UnitsToEquip)].Count := aCount;
end;
procedure AddMultiUnitsToEquip(aUnitTypes :array of TKMUnitType; aCount : Integer);
var I : Integer;
begin
	for I := 0 to high(aUnitTypes) do 
		AddUnitsToEquip(aUnitTypes[I], aCount);
end;
procedure RemoveUnitsToEquip(aIndex : Integer);
var I: Integer;
begin
	for I := aIndex to high(UnitsToEquip) - 1 do
		UnitsToEquip[I] := UnitsToEquip[I + 1];
	SetLength(UnitsToEquip, high(UnitsToEquip));
end;

procedure AddMessage(aID, aTime : Integer);
begin
	IF MessageAdded[aID] then 	
		Exit;
	MessageAdded[aID] := true;
	SetLength(Messages, length(Messages) + 1);
	Messages[high(Messages)].ID := aID;
	Messages[high(Messages)].Time := aTime;
end;

procedure AddMessageLoc(aID, aTime : Integer; aLoc : TKMPoint);
begin
	IF MessageAdded[aID] then 	
		Exit;
	MessageAdded[aID] := true;
	SetLength(Messages, length(Messages) + 1);
	Messages[high(Messages)].ID := aID;
	Messages[high(Messages)].Time := aTime;
	Messages[high(Messages)].Loc := aLoc;
end;

procedure AddMessages(aIDs : array of Integer; aStartTime, aTimeSpace : Integer);
var I : Integer;
begin
	for I := 0 to high(aIDs) do 
		AddMessage(aIDs[I], aStartTime + (aTimeSpace * I) );
end;

function AreHousesBuilt(aHouses : array of TKMHouseType) : Boolean;
var I : Integer;
begin
	Result := true;
	for I := 0 to high(aHouses) do
		Result := Result and HousesBuilt[S.HouseTypeToID(aHouses[I])  ] 
end;

procedure RemoveMessage(aIndex : Integer);
var I: Integer;
begin
	for I := aIndex to high(Messages) - 1 do
		Messages[I] := Messages[I + 1];
	SetLength(Messages, high(Messages));
end;

function IntToMsg(aID : Integer) : String;
begin
	Result := '<$' + IntToStr(aID) + '>';
end;

procedure AddToStr(var aString : String; add : String);
begin
	aString := aString + add;
end;

procedure AppendWaresToGather;
var I, C : Integer;
	finString : String;
	canWin : Boolean;
begin
	If length(ResourcesToGather) = 0 then 
		Exit;
	canWin := WIN_AFTER_GETTING_ALL_WARES;
	finString := '';
	//AddToStr(finString, IntToMsg(20));
	for I := 0 to high(ResourcesToGather) do 
	begin
		C := S.StatResourceTotalCount(0, ResourcesToGather[I].WT);
		AddToStr(finString, '|');
		IF C >= ResourcesToGather[I].Count then 
			AddToStr(finString, '[$00FF00]')
		else
			canWin := false;
			
		AddToStr(finString, U.Format('%s : %d / %d', [S.WareTypeNameEx(ResourcesToGather[I].WT), C, ResourcesToGather[I].Count]));
		AddToStr(finString, '[$FFFFFF]');
	end;
	A.OverlayTextAppend(0, finString);
	IF canWin and (WinTime = 0) then 
		WinTime := S.GameTime + 20;
end;

procedure AppendUnitsToEquip;
var I, C : Integer;
	finString : String;
	canWin : Boolean;
begin
	If length(UnitsToEquip) = 0 then 
		Exit;
	canWin := WIN_AFTER_GETTING_ALL_WARES;
	finString := '';
	//AddToStr(finString, IntToMsg(20));
	for I := 0 to high(UnitsToEquip) do 
	begin
		C := S.StatUnitTypeCountEx(0, UnitsToEquip[I].UT);
		AddToStr(finString, '|');
		IF C >= UnitsToEquip[I].Count then 
			AddToStr(finString, '[$00FF00]')
		else
			canWin := false;
			
		AddToStr(finString, U.Format('%s : %d / %d', [S.UnitTypeNameEx(UnitsToEquip[I].UT), C, UnitsToEquip[I].Count]));
		AddToStr(finString, '[$FFFFFF]');
	end;
	A.OverlayTextAppend(0, finString);
	IF canWin and (WinTime = 0) then 
		WinTime := S.GameTime + 20;
end;

procedure OnFieldPlanDigged(aPlayer, aX, aY : Integer; aType : TKMLockFieldType);
begin

end;

procedure OnFieldPlanBuilt(aPlayer, aX, aY : Integer; aType : TKMLockFieldType);
begin
end;

procedure OnHousePlanPlacedEx(aPlayer, aX, aY : Integer; aType : TKMHouseType);
begin
end;

procedure UnlockHouse(aType : TKMHouseType);
begin
	A.HouseAllow(0, S.HouseTypeToID(aType)- 1, true);
	A.HouseUnlock(0, S.HouseTypeToID(aType) - 1);
end;

var	SiloUpgraded : Boolean;
procedure OnHouseUpgraded(aHouse : integer; aLevel : Integer);
begin
	If SiloUpgraded then 
		Exit;
	If not (S.HouseTypeEx(aHouse) = htSmallStore) then 
		Exit;
	AddMessages([10], S.GameTime + 30, MSG_DELAY);
	OverlayTopMessage := IntToMsg(BUILD_HOUSE_MSG);		
	BuildHouses := [htCollectors];
	SiloUpgraded := true;
end;

procedure OnHouseBuilt(aHouse : Integer);
begin
	If S.HouseOwner(aHouse) <> 0 then 
		Exit;
	If HousesBuilt[S.HouseTypeToID(S.HouseTypeEx(aHouse))] then 
		Exit;
	HousesBuilt[S.HouseTypeToID(S.HouseTypeEx(aHouse))] := true;
	//add messages
	case S.HouseTypeEx(aHouse) of
		htForest	: 	begin	
							AddMessages([4, 5, 6], S.GameTime + 30, MSG_DELAY);	
							UnlockHouse(htPasture);
						end;
		htPasture	: 	begin	
							AddMessages([7, 8], S.GameTime + 30, MSG_DELAY);	
							UnlockHouse(htSiegeTower);
						end;
		htSiegeTower:	begin	
							AddMessages([9, 10], S.GameTime + 30, MSG_DELAY);	
							UnlockHouse(htCartographers);
						end;
		htCartographers:	begin	
							AddMessages([11, 12], S.GameTime + 30, MSG_DELAY);	
							UnlockHouse(htGoldMine);
							UnlockHouse(htCoalMine);
							MustBuildShaft := true;
						end;
		htGoldMine,
		htCoalMine : If HousesBuilt[S.HouseTypeToID(htGoldMine)] 
						and HousesBuilt[S.HouseTypeToID(htCoalMine)] then 
						begin
							AddMessages([14, 15], S.GameTime + 30, MSG_DELAY);	
							UnlockHouse(htArena);
						end;
		htArena:	begin	
							AddMessages([16, 17], S.GameTime + 30, MSG_DELAY);	
							UnlockDev := true;	
							A.FestivalPointsAdd(0, 0, 1000);
							A.FestivalPointsAdd(0, 1, 1000);
							A.FestivalPointsAdd(0, 2, 1000);
						end;
		else
			Exit;
	end;
	//new mesages
	case S.HouseTypeEx(aHouse) of		
		htForest: OverlayTopMessage := IntToMsg(BUILD_HOUSE_MSG);
		htPasture: OverlayTopMessage := IntToMsg(BUILD_HOUSE_MSG);
		htSiegeTower: OverlayTopMessage := IntToMsg(BUILD_HOUSE_MSG);
		htCartographers: OverlayTopMessage := IntToMsg(28);
		htGoldMine,
		htCoalMine : If HousesBuilt[S.HouseTypeToID(htGoldMine)] 
						and HousesBuilt[S.HouseTypeToID(htCoalMine)] then 
						OverlayTopMessage := IntToMsg(BUILD_HOUSE_MSG);
		htArena:	 OverlayTopMessage := IntToMsg(27);
	end;
	//houses to build
	case S.HouseTypeEx(aHouse) of
		htForest:				BuildHouses := [htPasture];	
		htPasture:				BuildHouses := [htSiegeTower];	
		htSiegeTower:				BuildHouses := [htCartographers];	
		htCartographers:				BuildHouses := [];	
		htGoldMine,
		htCoalMine : If HousesBuilt[S.HouseTypeToID(htGoldMine)] 
						and HousesBuilt[S.HouseTypeToID(htCoalMine)] then 
							BuildHouses := [htArena];	
		htArena:		BuildHouses := [];	
	end;
end;

procedure OnStructureBuilt(aOwner : Integer; aX, aY, aIndex : Integer);
begin
	If not MustBuildShaft then
		Exit;
		
	AddMessages([13], S.GameTime + 30, MSG_DELAY);	
	OverlayTopMessage := IntToMsg(BUILD_HOUSE_MSG);
	BuildHouses := [htGoldmine, htCoalMine];	
	MustBuildShaft := false;
end;

procedure OnDevUnlocked(aOwner : Integer; aType, aID : Integer);
begin
	If not UnlockDev then
		Exit;
		
	WinTime := S.GameTime + 20;
	UnlockDev := false;
end;

procedure OnTick;
var I : Integer;
begin
	If S.GameTime = 200 then 
	begin
		BuildHouses := [htForest];
		OverlayTopMessage := IntToMsg(BUILD_HOUSE_MSG);
	end;
	
	for I := high(Messages) downto 0 do
		If S.GameTime >= Messages[I].Time then 
		begin
			If Messages[I].Loc.X > 0 then 
				A.ShowMsgGoto(-1, Messages[I].Loc.X, Messages[I].Loc.Y, IntToMsg(Messages[I].ID))
			else
				A.ShowMsg(-1, IntToMsg(Messages[I].ID) );
			RemoveMessage(I);
		end;
	//show overlays
	If S.GameTime mod 10 = 0 then 
	begin
		A.OverlayTextSet(0, OverlayTopMessage);
		If length(BuildHouses) > 0 then 
			for I := 0 to high(BuildHouses) do 
			begin
				If HousesBuilt[S.HouseTypeToID(BuildHouses[I])] then 
					A.OverlayTextAppend(0, '[$00FF00]')
				else
					A.OverlayTextAppend(0, '[$FFFFFF]');
					
				A.OverlayTextAppendFormatted(0, '%s', [S.HouseTypeNameEx(BuildHouses[I])]);
				A.OverlayTextAppend(0, '[$FFFFFF] ; ');
			end;
		AppendWaresToGather;
		AppendUnitsToEquip;
	end;
	
	If WinTime > 0 then 
	begin	
		if S.GameTime = WinTime then 
			A.ShowMsg(0, IntToMsg(WIN_MSG));
		if S.GameTime = WinTime + MSG_DELAY then 
		begin
			A.PlayerWin([0], false);
			A.ShowMsg(0, IntToMsg(CHEAT_MSG));
		end;
	end;
		
end; 

procedure OnMissionStart;
begin
	AddMessages([0, 1, 2, 3], 1, MSG_DELAY);
	
	WinTime := 0;
	OverlayTopMessage := '';
	//OverlayTopMessage := IntToMsg(21);
end;