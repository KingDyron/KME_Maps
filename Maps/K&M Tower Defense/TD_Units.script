


//return map ID
Function AddLifes(Addition : Integer) : Integer;
begin
	with gMaps.CurrentSaveData do 
	begin
		Lifes := Lifes + Addition;
		
		If Lifes > LIFES_LIMIT then
			Lifes := LIFES_LIMIT;
			
		If Lifes < 0 then 
		begin
			Lifes := 0;
			QuitMapLost;
		end;
		Result := Lifes;
	end;
	UpdateOverlay;
end;

Procedure AutoFeed(aPlayer : Integer);
var aArray : array of Integer;
	I : Integer;
begin
	aArray := S.PlayerGetAllUnits(aPlayer);
	If Length(aArray) = 0 then 
		Exit;
		
	for I := 0 to high(aArray) do 
		A.UnitHungerSet(aArray[I], 27000);
end;

function GetUnitID(aUnit : Integer) : Integer;
var I : Integer;
begin
	Result := -1;
	If length(gEnemyUnits) = 0 then 
		Exit;
	for I := 0 to high(gEnemyUnits) do 
		If aUnit = gEnemyUnits[I].ID then 
		begin
			Result := I;
			Break;
		end;
		
end;


procedure ChangeBossType;
begin
	//ACheck(IntToStr(gMaps.WaveID div 5));
	case (gMaps.WaveID div 5) mod 10 of
		0: gMaps.BossType := 13;
		1: gMaps.BossType := 13;
		2: gMaps.BossType := 13;
		3: gMaps.BossType := 11;
		4: gMaps.BossType := 11;
		5: gMaps.BossType := 38;
		6: gMaps.BossType := 11;
		7: gMaps.BossType := 13;
		8: gMaps.BossType := 38;
		9: gMaps.BossType := 46;
	end;
	{If (gMaps.BossType = 13) then 
		gMaps.BossType := 11
	else
	If (gMaps.BossType = 11) then 
		gMaps.BossType := 38
	else
	If (gMaps.BossType = 38) then 
		gMaps.BossType := 46
	else
	If (gMaps.BossType = 46) then 
		gMaps.BossType := 13;}
end;

 // returns true if unit was killed near store
function WalkToNextCorner(var aUnit : KD_UnitStats) : Boolean;
var aLastCorner : Boolean;
	aCorner, UU, HH : Integer;
	aMap : TD_MapData;
	aPos : TKMPoint;
begin
	Result := false
	aCorner := aUnit.PosID + 1;
	UU := aUnit.ID;
	aMap := gMaps.Map[gMaps.SelectedId];
	aPos := S.UnitPosition(aUnit.ID);
	HH := S.HouseAt(aPos.X, aPos.Y - 1);
	//check if he is at the end position;
	If (length(aMap.RoadData.Corners) = 0) or (aUnit.PosID > high(aMap.RoadData.Corners)) then 
	If S.HouseType(HH) = 11 then 
	begin
		KillInvulnerableUnit(aUnit.ID, true);
		If aUnit.IsBoss then 
			AddLifes(-10)
		else
			AddLifes(-1);
		aUnit.Killed := true;
		ClearUnitsArray;
		Result := true;
		If aUnit.IsBoss then 
			ChangeBossType;
		Exit;
	end else
	begin
		If aUnit.Destination <> U.KMPoint(-1, -1) then 
			A.UnitOrderWalk(UU, aUnit.Destination.X, aUnit.Destination.Y );	
		Exit;
		
	end;
	
	If aCorner > High(aMap.RoadData.Corners) then 
		aLastCorner := true;
		
	If aLastCorner then 
	begin
		inc(aUnit.PosID);
		with aMap.RoadData do 
			A.UnitOrderWalk(UU, StorePos[0].X, StorePos[0].Y );		
	end else
	begin
		inc(aUnit.PosID);
		
		with aMap.RoadData do 
			A.UnitOrderWalk(UU, Corners[aCorner].X, Corners[aCorner].Y );		
		
	end;

end;
Procedure UnitChangeHP(var aUnit : KD_UnitStats; var aTower : TD_Tower);
begin
	With aUnit do 
	begin
		If aTower.IsWatchTower then
		begin
			If aUnit.UType = 11 then 
				HP := HP - (aTower.Attack * 2)
			else
				HP := HP - aTower.Attack;
		end else
		If byte(UType) in aTower.BonusFor then 			
			HP := HP - (aTower.Attack * 2)
		else
		If byte(aTower.aUnit.UType) in BonusFor then 
			HP := HP - (aTower.Attack div 2)	
		else
			HP := HP - aTower.Attack;
			
		If IsBoss then 
			UpdateOverlay;
			
		If HP <= 0 then
		begin
			Killed := true;
			KillInvulnerableUnit(ID, false);
			ClearUnitsArray;
			If IsBoss then 
				ChangeBossType;
			
			AddMoneyAfterKill(MoneyAtKill);
				
		end;
	end;
end;



procedure CheckUnitsPoses;
var I : Integer;
	ClearOverlay : Boolean;
begin
	If length(gEnemyUnits) = 0 then 
		Exit;
		
	for I := 0 to high(gEnemyUnits) do 
		If S.UnitIdle(gEnemyUnits[I].ID) then 
			If WalkToNextCorner(gEnemyUnits[I]) then 
				ClearOverlay := true;
	If ClearOverlay then 
		UpdateOverlay;
end;

//Rough and faster Length as combination of straight and diagonal
function KMLengthDiag(const A, B: TKMPoint): Single;
var
  absX, absY: Integer;
begin
  absX := U.AbsI(A.X - B.X);
  absY := U.AbsI(A.Y - B.Y);
  if absX > absY then
    Result := absX + absY * 0.41
  else
    Result := absY + absX * 0.41;
end;

procedure TowerRangedAttackSingle(aGID : Integer; aPos : TKMPoint);
var UID, aUnit : Integer;
	I : Integer;
	LastDistance, dist : Single;
begin		
	If length(gEnemyUnits) = 0 then 
		Exit;
		
	A.GroupOrderHalt(aGID);
	LastDistance := 999999;
	for I := 6 downto 2 do 
	begin
		UID := S.ClosestUnit(I, aPos.X, aPos.Y, -1);
		
		
		
		If (UID > 0) then 
		begin
			dist := KMLengthDiag(aPos, S.UnitPosition(UID));
			if dist < LastDistance then 
			begin
				aUnit := UID;
				LastDistance := dist
			end;
		end;
	end;
	IF aUnit > 0 then 
		A.GroupOrderAttackUnit(aGID, UID);
end;

procedure TowerRangedAttack;
var J : Integer;
begin
	with gMaps.CurrentSaveData do 
		If length(RangedTowers) = 0 then 
			Exit
		else
		for J := 0 to high(RangedTowers) do 
			If RangedTowers[J].aUnit.Deleted then 
				Continue
			else
			with RangedTowers[J] do 
				TowerRangedAttackSingle(aUnit.GID, aUnit.Pos);
end;

procedure UpgradeTowerChangeType;
begin
	with gMaps.CurrentSaveData.Towers[gUpgrade.Pos.X] do 
	begin
		aUnit := SetWarrior(SingleGroup(MAP_PLAYER, aUnit.UType, aUnit.Pos));
		A.UnitHPSetInvulnerable(aUnit.ID, true);
		A.GroupInfiniteAmmoSet(aUnit.GID, true);
		A.UnitBlockWalking(aUnit.ID, true);
		If  IsTowerRanged(aUnit) then 
			RefreshRangedUnits;
		OverlayUnitStats(aUnit.ID);
		ShowPanel(ptStats);
	end;
end;

function UpgradeTower(aPos : TKMPoint) : Integer;
var TID, aUpgCost, aNType : Integer;
begin
	
	TID := GetTowerIDFromPos(aPos);
	//ACheck('TowerUpgrade ' + IntToStr(TID));
	Result := TID;	
	
	If TID = -1 then 
		Exit;
		
	with gMaps.CurrentSaveData.Towers[TID] do 
	begin
		aUpgCost := GetTowerUpgradeCost(aUnit.UType, LVL, IsWatchTower);
		
			
		If HasEnoughMoney(aUpgCost) then 
		begin
			AddMoney(-aUpgCost);
			If not IsWatchTower then 
				If GetTowerNextType(aUnit.UType) <> -1 then 
				begin
					aNType := GetTowerNextType(aUnit.UType);
					Cost := Cost + (aUpgCost * 80 div 100);
					Attack := GetTowerDamage(aNType);
					KillInvulnerableUnit(aUnit.ID, true);
					aUnit.UType := aNType;
					UpgTime := GT;
					gUpgrade.Time := UpgTime;
					gUpgrade.Pos.X := TID;
					gUpgrade.Pos.Y := aNType;
					//ACheck('TowerUpgrade to Type ' + IntToStr(Attack) + ' '+ IntToStr(aUpgCost));
					Exit;
				end;
			
			Cost := Cost + (aUpgCost * 80 div 100);
			Attack := GetTowerUpgradeDamage(aUnit.UType, LVL, IsWatchTower);
			//ACheck('TowerUpgrade ' + IntToStr(Attack) + ' '+ IntToStr(aUpgCost));
			inc(LVL);
			gMaps.SelectedTower := gMaps.CurrentSaveData.Towers[TID];
			gMaps.SelectedHouse.ID := -1;
			OverlayUnitStats(gMaps.SelectedTower.aUnit.ID);
		end else
			If IsWatchTower then 
				A.ShowMSGFormatted(PLAYER, '<$22>%s |<$21>%d / %d <$9>', [S.HouseTypeName(aUnit.UType), gMoney, aUpgCost])
			else
				A.ShowMSGFormatted(PLAYER, '<$22>%s |<$21>%d / %d <$9>', [S.UnitTypeName(aUnit.UType), gMoney, aUpgCost])
		
	end;
end;


function SpawnUnit : Integer;
var J, RID : Integer;
	aStartPos, aSecPos : TKMPoint;
	UU : KD_UnitStats;
begin
	If not gMaps.MapHasBegun then 
		gMaps.MapHasBegun := true;
	with gMaps.Map[gMaps.SelectedId].RoadData do
	begin	
		If length(SchoolPos) > 1 then 
		begin
			Inc(gMaps.RoadID)
			If gMaps.RoadID > high(SchoolPos) then 
				gMaps.RoadID := 0;
				
			RID := gMaps.RoadID;
		end;
		aStartPos := SchoolPos[RID];
		
		If length(Corners) = 0 then 
			aSecPos := StorePos[RID]
		else
			aSecPos := Corners[0];
	end;
	IF gMaps.CurrentSaveData.UnitType > 13 then 
		UU := SetUnit(GroupLeader( A.GiveGroup(gMaps.UnitPlayer,
												gMaps.CurrentSaveData.UnitType,
												aStartPos.X, aStartPos.Y, 4, 1, 1
												) 
								) 
					)
		//A.GiveUnit(gMaps.UnitPlayer, gMaps.CurrentSaveData.UnitType, aStartPos.X, aStartPos.Y, 4))
	else
		UU := SetUnit(A.GiveUnit(gMaps.UnitPlayer, gMaps.CurrentSaveData.UnitType, aStartPos.X, aStartPos.Y, 4));
	
	//inc(gMaps.UnitPlayer)
	//if gMaps.UnitPlayer > 5 then 
		gMaps.UnitPlayer := 2;
		
	UU.HP := gMaps.CurrentSaveData.WaveUnitHP;
	UU.BonusFor := GetUnitBonus(UU.UType)
	//A.UnitBootsSet(UU.ID, true);
	case UU.Utype of
		11 : UU.MoneyAtKill := 400;
		13 : UU.MoneyAtKill := 100;
		38 : UU.MoneyAtKill := 1000;
		46 : UU.MoneyAtKill := 2000;
		else UU.MoneyAtKill := 1;
	end;
	A.UnitOrderWalk(UU.ID, aSecPos.X, aSecPos.Y);
	A.UnitHPSetInvulnerable(UU.ID, true);
	with gMaps.Map[gMaps.SelectedId].RoadData do
		If length(Corners) = 0 then 
			UU.Destination := aSecPos
		else
			UU.Destination := U.KMPoint(-1, -1);
	
	J := length(gEnemyUnits);
	SetLength(gEnemyUnits, J + 1);
	
	Result := J;
	
	gEnemyUnits[J] := UU;
	
	With gMaps do 
	begin	
		If not (byte(gMaps.CurrentSaveData.UnitType) in [11, 13, 45, 38]) then 
		begin
			UnitSpawnTime := GT + UnitSpawnDelay;
			inc(UnitSpawnedCount)
		end;
		If WaveID mod 7 = 0 then 
			A.UnitBootsSet(UU.ID, true);
		If UnitSpawnedCount = 20 then 	
		begin
			WaveTime := GT + 300;
			If WaveID mod 5 = 0 then 
			begin
				If GT > BossSpawnTime then 
					BossSpawnTime := GT + (UnitSpawnDelay * 5);
				
				//ACheck(IntToStr(BossSpawnTime));	
				WaveTime := GT + 1200;
				
			end;
				
			UnitSpawnTime := 99999999;
		end;
	end;
	//ACheck;
end;

procedure SpawnBoss;
var UType, UOwner, J : integer;
	
begin
	UType := gMaps.CurrentSaveData.UnitType;
	UOwner := gMaps.UnitPlayer;
	gMaps.CurrentSaveData.UnitType := gMaps.BossType;
	gMaps.UnitPlayer := 2;
	J := SpawnUnit;
	with gEnemyUnits[J] do 
	begin
		IsBoss := true;
		If gMaps.CurrentSaveData.UnitType = 13 then 
			HP := gMaps.CurrentSaveData.WaveUnitHPBefore * 7 * gCityBonuses.BossHP div 100
		else
		If gMaps.CurrentSaveData.UnitType = 38 then 
			HP := gMaps.CurrentSaveData.WaveUnitHPBefore * 5 * gCityBonuses.BossHP div 100
		else
		If gMaps.CurrentSaveData.UnitType = 46 then 
			HP := gMaps.CurrentSaveData.WaveUnitHPBefore * 4 * gCityBonuses.BossHP div 100
		else
			HP := gMaps.CurrentSaveData.WaveUnitHPBefore * 12 * gCityBonuses.BossHP div 100;
	end;
	gMaps.BossSpawnTime := -1;
	gMaps.BossID := J;
	 gMaps.UnitPlayer := UOwner;
	gMaps.CurrentSaveData.UnitType := UType;
end;

procedure SelectUnitType(aType : Byte);
var aCost : Integer;
	DoReload : Boolean;
begin
	with gTowerSelected do
	begin
		IF aType = 255 then 
			Exit;
		aCost := GetTowerCost(aType);
		If not HasEnoughMoney(aCost) then 
		begin
			A.ShowMSG(PLAYER, '<$20>' + S.UnitTypeName(aType) + '|<$21>' + IntToStr(gMoney) + ' / ' + IntToStr(aCost) + ' <$9>' );
			Exit;
		end;
		
		SendTutorialMSG(4);
		SendTutorialMSG(10);
		
		If (aUnit.UType > 0) and IsTowerRanged(aUnit) and not IsTypeRanged(aType) then 
			DoReload := true;
		If (aUnit.UType > 0) and not IsTowerRanged(aUnit) and IsTypeRanged(aType) then 
			DoReload := true;
			
		If IsHouse then 
			DoReload := true;
			
		If DoReload then 
			ShowUnitPlaces_Remove;
			
		If aUnit.UType = 0 then 
			DoReload := true;

		aUnit.UType := aType;
			
			
		IsHouse := false;
		IsWatchTower := false;
		
		If DoReload then 
		begin
			If aType = 59 then 
				ShowUnitPlaces(tbShip)
			else				
			If IsTowerRanged(aUnit) then 
				ShowUnitPlaces(tbRanged)
			else
				ShowUnitPlaces(tbMelee);
		end;
		
		SelectionTime := U.FloorTo(GT + 600, 10);
		//ACheck('Unit selected');
	end;
	gMode := gmPlaceUnit;
	UpdateOverlay;
end;

procedure SelectUnit(aPos : TKMPoint);
var UU : Integer;
begin
	UU := S.UnitAt(aPos.X, aPos.Y);
	If UU = -1 then 
	begin
		If gMode in [gmPlaceUnit, gmPlaceHouse] then 
			ShowUnitPlaces_Remove;
		ResetSelectedTower;
		gMode := gmGame;
		UpdateOverlay;
		Exit;
	end;
	SelectUnitType(S.UnitType(UU));
end;

procedure SelectHouseType(aType : Byte);
var aCost : Integer;
	DoReload : Boolean;
begin
	with gTowerSelected do
	begin
		DoReload := true;
		aCost := GetHouseCost(aType);
		If not HasEnoughMoney( aCost ) then 
		begin
			A.ShowMSG(PLAYER, '<$20>' + S.HouseTypeName(aType) + '|<$21>' + IntToStr(gMoney) + ' / ' + IntToStr(aCost)  + ' <$9>' );
			Exit;
		end;
		
		If (aUnit.UType > 0) and (aUnit.UType in [3, 14, 22]) and (aType in [3, 14, 22]) then 
			DoReload := false;
		
		If not IsHouse then 
			DoReload := true;
			
		If aUnit.UType > 0 then 
			If DoReload then 
				ShowUnitPlaces_Remove;
		
		If aUnit.UType = 0 then 
			DoReload := true;
			
		aUnit.UType := aType;
		
		Attack := 35;
		LVL := 1;
		
		IsHouse := true;
		Cost := 100;
		IsWatchTower := aUnit.UType = 17;
			
		If DoReload then 
			If gSettings.ShowHousesPlaces then 
				CheckAllPlacesForHouses;	
		
		SelectionTime := U.FloorTo(GT + 600, 10);
		//ShowUnitPlaces(tbHouse);
			
	end;
	gMode := gmPlaceHouse;
	UpdateOverlay;
end;

procedure SelectHouse(aPos : TKMPoint);
var HH : Integer;
begin
	HH := S.HouseAt(aPos.X, aPos.Y);
	If HH = -1 then 
	begin
		If gMode in [gmPlaceUnit, gmPlaceHouse] then 
			ShowUnitPlaces_Remove;
		ResetSelectedTower;
		gMode := gmGame;	
		UpdateOverlay;
		Exit;
	end;
	SelectHouseType(S.HouseType(HH));
	
end;

function TileIsBlocked(Pos : TKMPoint; tType : TD_TileBlock) : Boolean;
var PP : TKMPoint;
begin
	PP := GetMapPos(Pos);
	with gMaps.MapLandData.TileData[PP.X][PP.Y] do 
		Result := tType in Passability;
end;

{$EVENT evtHouseDamaged : OnHouseDamagedUnits}
procedure OnHouseDamagedUnits(aHouse,aAttacker : integer);
begin
	If aHouse > 0 then 
		A.HouseAddRepair(aHouse, 500);
end;

{$EVENT evtPlanRoadPlaced : OnPlanRoadPlacedUnits}
procedure OnPlanRoadPlacedUnits(aPlayer, X ,Y : integer);
begin
	A.PlanRemove(aPlayer, X ,Y);
end;
{$EVENT evtPlanWineFieldPlaced : OnPlanWineFieldPlacedUnits}
procedure OnPlanWineFieldPlacedUnits(aPlayer, X ,Y : integer);
begin
	A.PlanRemove(aPlayer, X ,Y);
end;

{$EVENT evtPlanFieldPlaced : OnPlanFieldPlacedUnits}
procedure OnPlanFieldPlacedUnits(aPlayer, X ,Y : integer);
begin
	A.PlanRemove(aPlayer, X ,Y);
end;

{$EVENT evtUnitHit : OnUnitHitUnits}
//Unit Attacked change it's HP
procedure OnUnitHitUnits(aUnit, aKiller : Integer);
var aUIndex, aTIndex : Integer;
	aPos : TKMPoint;
begin
	If  not ( gMode in [gmGame, gmPlaceUnit, gmPlaceHouse]) then 
		Exit;
	aUIndex := GetUnitID(aUnit);
	aTIndex := GetTowerID(aKiller);
	
	If (S.UnitType(aKiller) in [38, 46]) and (S.UnitOwner(aKiller) <> MAP_PLAYER) then //if it's a ram then kill our towers
	begin
		If (GT > gRemove.Time + 3) or (gRemove.Time = 99999999) then 
		begin
			aPos := S.UnitPosition(aUnit);
			
			If KillTower(aUnit) <> -1 then //try to kill tower
			begin
				ClearTowersArray;
				SetRemove(aPos, 5);
				gRemove.aType := 25;
			end;
		end;
	end;
	If (aTIndex = -1) or (aUIndex = -1) then 
		Exit;
	
	UnitChangeHP(gEnemyUnits[aUIndex], gMaps.CurrentSaveData.Towers[aTIndex]);
end;

procedure GiveHousesBonuses;
var I, GB : Integer;
begin
	with gMaps.CurrentSaveData do 
		If length(Houses) > 0 then 
			for I := 0 to high(Houses) do 
			begin
				GB := GetHouseWaveBonus(S.HouseType(Houses[I].ID));
				If GB > 20 then 
					AddMoney(GB)
				else
				If GB > 0 then 
					AddLifes(GB);
				If Houses[I].aType = 18 then
					If (gMaps.WaveID - Houses[I].PlacedAtWave) mod 10 = 0 then 
						inc(MoneyMP);
			end;
end;

{$EVENT evtUnitSelected : OnUnitSelectedUnits}
procedure OnUnitSelectedUnits(aPlayer, aUnit : Integer; aSelected : Integer);
begin
	If not (gMode in [gmGame, gmPlaceHouse, gmPlaceUnit]) then 
		Exit;
		
	If aPlayer <> PLAYER then 
		Exit;
	If aPlayer <> S.UnitOwner(aUnit) then 
		Exit;
	If aSelected = 1 then 
	begin
		ShowPanel(ptStats);
		OverlayUnitStats(aUnit);		
	end
	else
	begin
		ShowPanel(ptGame);
		gMaps.SelectedTower.aUnit.ID := -1;
		gMaps.SelectedHouse.ID := -1;		
	end;
	
end;

{$EVENT evtHouseSelected : OnHouseSelectedUnits}
procedure OnHouseSelectedUnits(aPlayer, aHouse : Integer; aSelected : Integer);
var wtPos : TKMPoint;
begin
	If not (gMode in [gmGame, gmPlaceHouse, gmPlaceUnit]) then 
		Exit;
		
	If aPlayer <> PLAYER then 
		Exit;
	If aPlayer <> S.HouseOwner(aHouse) then 
		Exit;
	If aSelected = 1 then 
	begin
		ShowPanel(ptStats);
		gMaps.SelectedTower.aUnit.ID := -1;
		If S.HouseType(aHouse) = 17 then 
		begin
			wtPos := S.HousePosition(aHouse);
			wtPos.Y := wtPos.Y + 1;
			OverlayUnitStats(gMaps.CurrentSaveData.Towers[GetTowerIDFromPos(wtPos)].aUnit.ID);
		end	else
			OverlayHouseStats(aHouse);
			//gMaps.SelectedHouse.ID := aHouse;
	end else
	begin
		ShowPanel(ptGame);
		gMaps.SelectedTower.aUnit.ID := -1;
		gMaps.SelectedHouse.ID := -1;
	end;
	//ShowPanel(ptStats);
end;


{$EVENT evtTick : OnTickUnits}
procedure OnTickUnits;
var CanPlace : Boolean;
	aPos : TKMPoint;
begin
	If  not ( gMode in [gmGame, gmPlaceUnit, gmPlaceHouse]) then 
		Exit;
	//render placing units/houses	
	If gMode = gmPlaceUnit then
	begin		
		aPos := CursorPos;
		If not  PosInMap(aPos) then
			SetCursor(crtX, 0, 0)
		else
		begin
			{If not gTowerSelected.IsWatchTower then 
				If IsTowerRanged(gTowerSelected.aUnit) then 
					CanPlace := TileIsBlocked(CursorPos, tbRanged)
				else
					CanPlace := TileIsBlocked(CursorPos, tbMelee);}
			CanPlace := S.MapTileSelected(aPos.X, aPos.Y);
			If CanPlace then 
				SetCursor(crtUnit, gTowerSelected.aUnit.UType, 0)
			else
				SetCursor(crtX, 0, 0);
		end;
	end else
	If gMode = gmPlaceHouse then
	begin		
		aPos := CursorPos;
		If not PosInMap(aPos) then
			SetCursor(crtX, 0, 0)
		else
		begin
			CanPlace := S.MapTileSelected(aPos.X, aPos.Y);
			If CanPlace then 
				SetCursor(crtHouseSite, gTowerSelected.aUnit.UType, 0)
			else
				SetCursor(crtX, 0, 0);
		end;
	end;
	
	If GT = gRemove.Time + 2 then 
		If gRemove.aType = 117 then 
			RefreshTilesPassabilities(gRemove.Pos, 5)
		else
			RefreshTilesPassabilities(gRemove.Pos, 2);
			
	If GT = gUpgrade.Time + 2 then 
		UpgradeTowerChangeType;
	If GT mod 10 <> 0 then 
		Exit;
	If GT = gMaps.UnitSpawnTime then 
		SpawnUnit;
		
	If GT = gMaps.BossSpawnTime then 
		SpawnBoss;
		
	CheckUnitsPoses;
	TowerRangedAttack;
	If GT mod 200 = 0 then 
		GiveStoneToTowers;
	If GT mod 9000 = 0 then 
	begin
		AutoFeed(PLAYER);
		AutoFeed(MAP_PLAYER);
		AutoFeed(CITY_PLAYER);
		AutoFeed(8);
	end;
	If GT = gTowerSelected.SelectionTime then 
	begin
		ResetSelectedTower;
		ShowUnitPlaces_Remove;
		gMode := gmGame;
		SetCursor(crtNone, 0, 0);
		UpdateOverlay;
		ResetHouseCostLabel;
	end;
	
	If GT = gMaps.WaveTime then 
	begin
		StartNextRound;
		GiveHousesBonuses;
	end;
end;

{$EVENT evtMissionStart : OnMissionStartUnits}
procedure OnMissionStartUnits;
begin
	//TowerPlace(17, U.KMPoint(31, 13), false);
	gMaps.DoAtMapQuit := @DeleteAllTowers;
	If not gTutorial.Skip then 
	A.ShowMSG(PLAYER, '<$63>');
	//A.PlayerAllianceChange(2, 0, false, true);
end;